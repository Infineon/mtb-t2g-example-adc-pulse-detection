/**********************************************************************************************************************
 * \file main.c
 * \copyright Copyright (C) Infineon Technologies AG 2019
 *
 * Use of this file is subject to the terms of use agreed between (i) you or the company in which ordinary course of
 * business you are acting and (ii) Infineon Technologies AG or its licensees. If and as long as no such terms of use
 * are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization obtaining a copy of the software and
 * accompanying documentation covered by this license (the "Software") to use, reproduce, display, distribute, execute,
 * and transmit the Software, and to prepare derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including the above license grant, this restriction
 * and the following disclaimer, must be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are solely in the form of
 * machine-executable object code generated by a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 *********************************************************************************************************************/
/*********************************************************************************************************************/
/*-----------------------------------------------------Includes------------------------------------------------------*/
/*********************************************************************************************************************/

#include "cybsp.h"
#include "cy_retarget_io.h"
#include "mtb_hal.h"

/* For the Retarget -IO (Debug UART) usage */
static cy_stc_scb_uart_context_t    UART_context;           /** UART context */
static mtb_hal_uart_t               UART_hal_obj;           /** Debug UART HAL object  */

/*********************************************************************************************************************/
/*------------------------------------------------------Macros-------------------------------------------------------*/
/*********************************************************************************************************************/
/* ADC interrupt priority */
#define IRQ_PRIORITY         2

/* Shift value for CPU IRQ number ('intSrc' of cy_stc_sysint_t consists of CPU IRQ number and system IRQ number) */
#define CPU_IRQ_NUMBER_SHIFT 16

/* ADC Pulse Detection positive reload values */
#define POSITIVE_RELOAD_4    4
#define POSITIVE_RELOAD_5    5
#define POSITIVE_RELOAD_6    6

/*********************************************************************************************************************/
/*---------------------------------------------Function Implementations----------------------------------------------*/
/*********************************************************************************************************************/

/**********************************************************************************************************************
 * Function Name: handleAdcIrq
 * Summary:
 *  ADC Interrupt Handler
 * Parameters:
 *  none
 * Return:
 *  none
 **********************************************************************************************************************
 */
void handleAdcIrq(void)
{
    uint32_t irqStatus;
        
    /* Get interrupt source */
    irqStatus = Cy_SAR2_Channel_GetInterruptStatusMasked(SARADC_HW, SARADC_PulseDetectionChannel_IDX);

    if ((irqStatus == CY_SAR2_INT_CH_PULSE) || (irqStatus == CY_SAR2_INT_CH_RANGE))
    {
        /* Toggle USER_LED port pin to HIGH and to LOW to indicate an interrupt event */
        Cy_GPIO_Set(CYBSP_USER_LED_PORT, CYBSP_USER_LED_PIN);
        
        /* LED ON for displaying */
        Cy_SysLib_DelayUs(300);

        Cy_GPIO_Clr(CYBSP_USER_LED_PORT, CYBSP_USER_LED_PIN);
        
        /* Clear interrupt flag depending on the interrupt source */
        if(irqStatus == CY_SAR2_INT_CH_PULSE)
        {
            Cy_SAR2_Channel_ClearInterrupt(SARADC_HW, SARADC_PulseDetectionChannel_IDX, CY_SAR2_INT_CH_PULSE);
        }
        else
        {
            Cy_SAR2_Channel_ClearInterrupt(SARADC_HW, SARADC_PulseDetectionChannel_IDX, CY_SAR2_INT_CH_RANGE);    
        }
    }
    else
    {
        /* Unexpected interrupt */
        CY_ASSERT(false);
    }
    
    
}

/**********************************************************************************************************************
 * Function Name: printMenu
 * Summary:
 *  Displays a menu on a terminal window to select actions.
 * Parameters:
 *  none
 * Return:
 *  none
 **********************************************************************************************************************
 */
static void printMenu(void)
{
    /* \x1b[2J\x1b[;H - ANSI ESC sequence for clear screen */
    printf("\x1b[2J\x1b[;H");

    printf("***********************************************************\r\n");
    printf("ADC Pulse Detection\r\n");
    printf("***********************************************************\r\n");
    printf(">> Select one of the options as listed below\r\n");
    printf(">> p : ADC Pulse Detection mode\r\n");
    printf(">> r : ADC Range Detection mode\r\n");
    printf(">> 4 : Set Positive Reload Value to '4'\r\n");
    printf(">> 5 : Set Positive Reload Value to '5'\r\n");
    printf(">> 6 : Set Positive Reload Value to '6'\r\n");
}

/**********************************************************************************************************************
 * Function Name: configureAdcPulseDetectionMode
 * Summary:
 *  Sets the ADC post-processing mode and the positive reload value for ADC Pulse Detection.
 *  Initializes SAR ADC module, enables interrupt and starts conversion.
 * Parameters:
 *  processingMode - post-processing mode selection
 *  reloadValue - reload value for positive counter of pulse detection
 * Return:
 *  none
 **********************************************************************************************************************
 */
static void configureAdcPulseDetectionMode(cy_en_sar2_post_processing_mode_t processingMode, uint16_t reloadValue)
{
    /* SAR block is disabled for setting up new parameters */
    Cy_SAR2_Disable(SARADC_HW);
    
    /* Set post-processing mode and positive reload value to the parameter structure */
    SARADC_PulseDetectionChannel_config.postProcessingMode = processingMode;
    SARADC_PulseDetectionChannel_config.positiveReload = reloadValue;      
    
    /* Initialize the SAR module with new parameter set */
    Cy_SAR2_Init(SARADC_HW, &SARADC_config);
    
    /* (Re-)Enable SAR block */
    Cy_SAR2_Enable(SARADC_HW);

    /* Set up the interrupt processing for ADC */
    cy_stc_sysint_t irqCfg =
    {
        .intrSrc = ((NvicMux3_IRQn << CPU_IRQ_NUMBER_SHIFT) | SARADC_PulseDetectionChannel_IRQ),
        .intrPriority = IRQ_PRIORITY,
    };
    if (Cy_SysInt_Init(&irqCfg, &handleAdcIrq) != CY_SYSINT_SUCCESS)
    {
        CY_ASSERT(0);
    }
    NVIC_EnableIRQ((IRQn_Type) NvicMux3_IRQn);    

    /* Handle interrupt mask configuration dependent on the post-processing mode */
    if (processingMode == CY_SAR2_POST_PROCESSING_MODE_RANGE_PULSE)
    {
        Cy_SAR2_Channel_SetInterruptMask(SARADC_HW, SARADC_PulseDetectionChannel_IDX, CY_SAR2_INT_CH_PULSE);
    }
    else
    {
        Cy_SAR2_Channel_SetInterruptMask(SARADC_HW, SARADC_PulseDetectionChannel_IDX, CY_SAR2_INT_CH_RANGE);
    }
    
    /* Start first ADC conversion, the ADC will then be re-triggered by hardware in continuous mode */
    Cy_SAR2_Channel_SoftwareTrigger(SARADC_HW, SARADC_PulseDetectionChannel_IDX);
}

/**********************************************************************************************************************
 * Function Name: main
 * Summary:
 *  This is the main function. It configures an ADC channel which is connected to the potentiometer.
 *  A menu is displayed on the terminal (115200 Baud). The user can choose between different actions:
 *   - Switching from Range or Pulse Detection Mode.
 *   - Set positive reload values from 4 to 6 which changes the timing to get a Pulse Detection interrupt.
 *  Status information are displayed for each action. Configurations for ADC and port pins are defined in
 *  "cycfg_peripherals.h". Any changes should be done in the device configurator.
 * Parameters:
 *  none
 * Return:
 *  int
 **********************************************************************************************************************
 */
int main(void)
{
    cy_rslt_t result;

    /* Variable to store the received character through terminal */ 
    uint8_t uartReadValue;     

    /* Initialize the device and board peripherals */
    if (cybsp_init() != CY_RSLT_SUCCESS)
    {
        CY_ASSERT(0);
    }
    
    /* Debug UART init */
    result = (cy_rslt_t)Cy_SCB_UART_Init(UART_HW, &UART_config, &UART_context);

    /* UART init failed. Stop program execution */
    if (result != CY_RSLT_SUCCESS)
    {
        CY_ASSERT(0);
    }

    Cy_SCB_UART_Enable(UART_HW);

    /* Setup the HAL UART */
    result = mtb_hal_uart_setup(&UART_hal_obj, &UART_hal_config, &UART_context, NULL);

    /* HAL UART init failed. Stop program execution */
    if (result != CY_RSLT_SUCCESS)
    {
        CY_ASSERT(0);
    }

    result = cy_retarget_io_init(&UART_hal_obj);

    /* HAL retarget_io init failed. Stop program execution */
    if (result != CY_RSLT_SUCCESS)
    {
        CY_ASSERT(0);
    }

    /* Initialize the SAR module */
    cy_en_sar2_post_processing_mode_t postProcessingMode = CY_SAR2_POST_PROCESSING_MODE_RANGE_PULSE;
    uint16_t positiveReload = POSITIVE_RELOAD_4;
    configureAdcPulseDetectionMode(postProcessingMode, positiveReload);
    
    /* Enable global interrupts */
    __enable_irq();
    
    /* Print menu on the terminal window */
    printMenu();

    for (;;)
    {
        /* Check if key was pressed and get input value */
        uartReadValue = Cy_SCB_UART_Get(UART_HW);
        
        if(uartReadValue != 0xff)
        {
            switch (uartReadValue)
            {
                /* Switch to Pulse Detection mode */
                case 'p':
                    printf("ADC Pulse Detection activated.\r\n");
                    postProcessingMode = CY_SAR2_POST_PROCESSING_MODE_RANGE_PULSE;
                    configureAdcPulseDetectionMode(postProcessingMode, positiveReload);
                    break;

                /* Switch to Range Detection mode */
                case 'r':
                    printf("ADC Range Detection activated.\r\n");
                    postProcessingMode = CY_SAR2_POST_PROCESSING_MODE_RANGE;
                    configureAdcPulseDetectionMode(postProcessingMode, positiveReload);   
                    break;
                
                /* Set positive reload value for Pulse Detection to value 4 */
                case '4':
                    printf("Positive Reload Value set to '4'\r\n");
                    positiveReload = POSITIVE_RELOAD_4;
                    configureAdcPulseDetectionMode(postProcessingMode, positiveReload);   
                    break;
                
                /* Set positive reload value for Pulse Detection to value 5 */
                case '5':
                    printf("Positive Reload Value set to '5'\r\n");
                    positiveReload = POSITIVE_RELOAD_5;
                    configureAdcPulseDetectionMode(postProcessingMode, positiveReload);   
                    break;
                
                /* Set positive reload value for Pulse Detection to value 6 */
                case '6':
                    printf("Positive Reload Value set to '6'\r\n");
                    positiveReload = POSITIVE_RELOAD_6;
                    configureAdcPulseDetectionMode(postProcessingMode, positiveReload);   
                    break;
                
                /* For all other keys pressed in the terminal print the user menu */
                default:
                    printMenu();
                    break;                    
            }
        }        
    }
}

/* [] END OF FILE */
